{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-b2ba84323df5157e44c873b10b7e85d41731a20a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/GrimStake.sol": "project/contracts/GrimStake.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/GrimStake.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/// @notice Minimal ERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n/**\r\n * @title GrimStake\r\n * @notice Multi-token staking vault with per-token reward rates.\r\n *         Users stake ERC20 tokens into pools; rewards are paid in the same token.\r\n *\r\n *         - Owner creates pools for specific token addresses.\r\n *         - Each pool has a rewardRate (tokens/second) funded by the owner.\r\n *         - Rewards use a MasterChef-style accRewardPerShare model.\r\n */\r\ncontract GrimStake {\r\n    // ------------------------------------------------------\r\n    // Basic Ownable\r\n    // ------------------------------------------------------\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"GrimStake: not owner\");\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Simple Reentrancy Guard\r\n    // ------------------------------------------------------\r\n    uint256 private _status;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"GrimStake: reentrant\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Staking Data Structures\r\n    // ------------------------------------------------------\r\n    struct TokenPool {\r\n        bool    enabled;            // pool active\r\n        uint256 rewardRate;         // tokens per second\r\n        uint256 lastRewardTime;     // last time accRewardPerShare was updated\r\n        uint256 accRewardPerShare;  // scaled by ACC_PRECISION\r\n        uint256 totalStaked;        // total tokens staked in this pool\r\n    }\r\n\r\n    struct UserStake {\r\n        uint256 amount;      // how many tokens the user has staked\r\n        uint256 rewardDebt;  // amount*accRewardPerShare/ACC at last action\r\n    }\r\n\r\n    // token address => pool data\r\n    mapping(address => TokenPool) public pools;\r\n\r\n    // user => token => stake data\r\n    mapping(address => mapping(address => UserStake)) public stakes;\r\n\r\n    // rewards precision\r\n    uint256 private constant ACC_PRECISION = 1e12;\r\n\r\n    // ------------------------------------------------------\r\n    // Events\r\n    // ------------------------------------------------------\r\n    event PoolCreated(address indexed token, uint256 rewardRate);\r\n    event RewardRateUpdated(address indexed token, uint256 newRate);\r\n    event Staked(address indexed user, address indexed token, uint256 amount);\r\n    event Unstaked(address indexed user, address indexed token, uint256 amount);\r\n    event RewardClaimed(address indexed user, address indexed token, uint256 amount);\r\n\r\n    // ------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------\r\n    constructor() {\r\n        owner = msg.sender;\r\n        _status = _NOT_ENTERED;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Admin / Owner functions\r\n    // ------------------------------------------------------\r\n\r\n    /// @notice Transfer ownership to a new address.\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"GrimStake: zero owner\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /// @notice Add a new staking pool for a token.\r\n    /// @param token ERC20 token address to be staked.\r\n    /// @param rewardRate Tokens per second distributed to stakers in this pool.\r\n    function addPool(address token, uint256 rewardRate) external onlyOwner {\r\n        require(token != address(0), \"GrimStake: zero token\");\r\n        TokenPool storage p = pools[token];\r\n        require(!p.enabled, \"GrimStake: pool exists\");\r\n\r\n        p.enabled = true;\r\n        p.rewardRate = rewardRate;\r\n        p.lastRewardTime = block.timestamp;\r\n\r\n        emit PoolCreated(token, rewardRate);\r\n    }\r\n\r\n    /// @notice Update the reward rate for an existing pool.\r\n    function setRewardRate(address token, uint256 newRate) external onlyOwner {\r\n        TokenPool storage p = pools[token];\r\n        require(p.enabled, \"GrimStake: pool not enabled\");\r\n\r\n        _updatePool(token);\r\n\r\n        p.rewardRate = newRate;\r\n        emit RewardRateUpdated(token, newRate);\r\n    }\r\n\r\n    /// @notice Owner can withdraw leftover reward tokens, if needed.\r\n    function rescueTokens(address token, address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"GrimStake: zero to\");\r\n        _safeTransfer(IERC20(token), to, amount);\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Core staking logic\r\n    // ------------------------------------------------------\r\n\r\n    /// @notice Stake `amount` of `token` into its pool.\r\n    function stake(address token, uint256 amount) external nonReentrant {\r\n        require(amount > 0, \"GrimStake: amount = 0\");\r\n        TokenPool storage p = pools[token];\r\n        require(p.enabled, \"GrimStake: pool not enabled\");\r\n\r\n        _updatePool(token);\r\n\r\n        UserStake storage u = stakes[msg.sender][token];\r\n\r\n        // Update user stake\r\n        u.amount += amount;\r\n        u.rewardDebt = (u.amount * p.accRewardPerShare) / ACC_PRECISION;\r\n\r\n        p.totalStaked += amount;\r\n\r\n        _safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\r\n\r\n        emit Staked(msg.sender, token, amount);\r\n    }\r\n\r\n    /// @notice Unstake `amount` of `token` from its pool (rewards remain claimable).\r\n    function unstake(address token, uint256 amount) external nonReentrant {\r\n        TokenPool storage p = pools[token];\r\n        require(p.enabled, \"GrimStake: pool not enabled\");\r\n\r\n        UserStake storage u = stakes[msg.sender][token];\r\n        require(u.amount >= amount, \"GrimStake: not enough staked\");\r\n\r\n        _updatePool(token);\r\n\r\n        u.amount -= amount;\r\n        u.rewardDebt = (u.amount * p.accRewardPerShare) / ACC_PRECISION;\r\n        p.totalStaked -= amount;\r\n\r\n        _safeTransfer(IERC20(token), msg.sender, amount);\r\n\r\n        emit Unstaked(msg.sender, token, amount);\r\n    }\r\n\r\n    /// @notice Claim all pending rewards for a token pool.\r\n    function claim(address token) external nonReentrant {\r\n        TokenPool storage p = pools[token];\r\n        require(p.enabled, \"GrimStake: pool not enabled\");\r\n\r\n        _updatePool(token);\r\n\r\n        UserStake storage u = stakes[msg.sender][token];\r\n\r\n        uint256 accumulated = (u.amount * p.accRewardPerShare) / ACC_PRECISION;\r\n        uint256 pending = accumulated - u.rewardDebt;\r\n        require(pending > 0, \"GrimStake: no rewards\");\r\n\r\n        u.rewardDebt = accumulated;\r\n\r\n        _safeTransfer(IERC20(token), msg.sender, pending);\r\n\r\n        emit RewardClaimed(msg.sender, token, pending);\r\n    }\r\n\r\n    /// @notice Convenience: claim rewards for multiple tokens in one call.\r\n    function claimMany(address[] calldata tokens_) external nonReentrant {\r\n        uint256 len = tokens_.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address token = tokens_[i];\r\n            TokenPool storage p = pools[token];\r\n            if (!p.enabled) continue;\r\n\r\n            _updatePool(token);\r\n\r\n            UserStake storage u = stakes[msg.sender][token];\r\n            uint256 accumulated = (u.amount * p.accRewardPerShare) / ACC_PRECISION;\r\n            uint256 pending = accumulated - u.rewardDebt;\r\n            if (pending == 0) continue;\r\n\r\n            u.rewardDebt = accumulated;\r\n            _safeTransfer(IERC20(token), msg.sender, pending);\r\n\r\n            emit RewardClaimed(msg.sender, token, pending);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Views for frontend\r\n    // ------------------------------------------------------\r\n\r\n    /// @notice Pending rewards for a user in a given pool.\r\n    function pendingRewards(address user, address token) external view returns (uint256) {\r\n        TokenPool storage p = pools[token];\r\n        UserStake storage u = stakes[user][token];\r\n\r\n        if (!p.enabled) return 0;\r\n\r\n        uint256 acc = p.accRewardPerShare;\r\n        if (block.timestamp > p.lastRewardTime && p.totalStaked != 0) {\r\n            uint256 timeDelta = block.timestamp - p.lastRewardTime;\r\n            uint256 reward = timeDelta * p.rewardRate;\r\n            acc += (reward * ACC_PRECISION) / p.totalStaked;\r\n        }\r\n\r\n        uint256 accumulated = (u.amount * acc) / ACC_PRECISION;\r\n        return accumulated - u.rewardDebt;\r\n    }\r\n\r\n    /// @notice Return basic stats for a pool (for analytics UI).\r\n    /// @dev APR is a rough estimate using rewardRate and totalStaked (basis points).\r\n    function getPoolStats(address token)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalStaked,\r\n            uint256 rewardRate,\r\n            uint256 aprBps\r\n        )\r\n    {\r\n        TokenPool storage p = pools[token];\r\n        totalStaked = p.totalStaked;\r\n        rewardRate = p.rewardRate;\r\n\r\n        if (p.totalStaked == 0 || p.rewardRate == 0) {\r\n            aprBps = 0;\r\n        } else {\r\n            // APR â‰ˆ (rewardRate * 365 days / totalStaked) * 10000\r\n            aprBps = (p.rewardRate * 365 days * 10000) / p.totalStaked;\r\n        }\r\n    }\r\n\r\n    /// @notice Return user's staked amount and rewardDebt (for debugging / UI).\r\n    function getUserStake(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 rewardDebt)\r\n    {\r\n        UserStake storage u = stakes[user][token];\r\n        amount = u.amount;\r\n        rewardDebt = u.rewardDebt;\r\n    }\r\n\r\n    // ------------------------------------------------------\r\n    // Internal helpers\r\n    // ------------------------------------------------------\r\n\r\n    function _updatePool(address token) internal {\r\n        TokenPool storage p = pools[token];\r\n        if (!p.enabled) return;\r\n\r\n        if (block.timestamp <= p.lastRewardTime) {\r\n            return;\r\n        }\r\n\r\n        if (p.totalStaked == 0) {\r\n            p.lastRewardTime = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 timeDelta = block.timestamp - p.lastRewardTime;\r\n        uint256 reward = timeDelta * p.rewardRate;\r\n\r\n        p.accRewardPerShare += (reward * ACC_PRECISION) / p.totalStaked;\r\n        p.lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    function _safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        if (amount == 0) return;\r\n        (bool success, bytes memory data) =\r\n            address(token).call(abi.encodeWithSelector(token.transfer.selector, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"GrimStake: transfer failed\");\r\n    }\r\n\r\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        if (amount == 0) return;\r\n        (bool success, bytes memory data) =\r\n            address(token).call(abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"GrimStake: transferFrom failed\");\r\n    }\r\n}\r\n\r\n"
      }
    }
  }
}